<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libvirt'>
  <files>
    <file name='libvirt'>
     <summary>core interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle Xen domains from a process running in domain 0 </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_NODEINFO_MAXCPUS' type='macro'/>
     <exports symbol='LIBVIR_VERSION_NUMBER' type='macro'/>
     <exports symbol='VIR_USE_CPU' type='macro'/>
     <exports symbol='VIR_CPU_MAPLEN' type='macro'/>
     <exports symbol='VIR_UUID_BUFLEN' type='macro'/>
     <exports symbol='VIR_CPU_USABLE' type='macro'/>
     <exports symbol='VIR_COPY_CPUMAP' type='macro'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LENGTH' type='macro'/>
     <exports symbol='VIR_UUID_STRING_BUFLEN' type='macro'/>
     <exports symbol='VIR_GET_CPUMAP' type='macro'/>
     <exports symbol='VIR_UNUSE_CPU' type='macro'/>
     <exports symbol='VIR_DEVICE_DEFAULT' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTDOWN' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_UINT' type='enum'/>
     <exports symbol='VIR_VCPU_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_CRASHED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_DOUBLE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_LLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_ULLONG' type='enum'/>
     <exports symbol='VIR_DOMAIN_DESTROY' type='enum'/>
     <exports symbol='VIR_DOMAIN_RESTART' type='enum'/>
     <exports symbol='VIR_DOMAIN_PRESERVE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' type='enum'/>
     <exports symbol='VIR_VCPU_OFFLINE' type='enum'/>
     <exports symbol='VIR_DOMAIN_RUNNING' type='enum'/>
     <exports symbol='VIR_DOMAIN_NOSTATE' type='enum'/>
     <exports symbol='VIR_DOMAIN_SHUTOFF' type='enum'/>
     <exports symbol='VIR_VCPU_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_SCHED_FIELD_INT' type='enum'/>
     <exports symbol='VIR_DOMAIN_PAUSED' type='enum'/>
     <exports symbol='VIR_DEVICE_RO' type='enum'/>
     <exports symbol='VIR_DEVICE_RW_FORCE' type='enum'/>
     <exports symbol='VIR_DOMAIN_NONE' type='enum'/>
     <exports symbol='VIR_DEVICE_RW' type='enum'/>
     <exports symbol='VIR_DOMAIN_BLOCKED' type='enum'/>
     <exports symbol='VIR_DOMAIN_RENAME_RESTART' type='enum'/>
     <exports symbol='virNodeInfoPtr' type='typedef'/>
     <exports symbol='virNetworkPtr' type='typedef'/>
     <exports symbol='virDomainInfoPtr' type='typedef'/>
     <exports symbol='virConnectPtr' type='typedef'/>
     <exports symbol='virVcpuInfoPtr' type='typedef'/>
     <exports symbol='virNodeInfo' type='typedef'/>
     <exports symbol='virNetwork' type='typedef'/>
     <exports symbol='virDomainState' type='typedef'/>
     <exports symbol='virDeviceMode' type='typedef'/>
     <exports symbol='virDomain' type='typedef'/>
     <exports symbol='virDomainPtr' type='typedef'/>
     <exports symbol='virSchedParameter' type='typedef'/>
     <exports symbol='virSchedParameterType' type='typedef'/>
     <exports symbol='virDomainRestart' type='typedef'/>
     <exports symbol='virConnect' type='typedef'/>
     <exports symbol='virDomainCreateFlags' type='typedef'/>
     <exports symbol='virSchedParameterPtr' type='typedef'/>
     <exports symbol='virDomainInfo' type='typedef'/>
     <exports symbol='virVcpuState' type='typedef'/>
     <exports symbol='virVcpuInfo' type='typedef'/>
     <exports symbol='_virDomainInfo' type='struct'/>
     <exports symbol='_virNodeInfo' type='struct'/>
     <exports symbol='_virVcpuInfo' type='struct'/>
     <exports symbol='_virSchedParameter' type='struct'/>
     <exports symbol='virDomainGetInfo' type='function'/>
     <exports symbol='virNetworkFree' type='function'/>
     <exports symbol='virNetworkGetName' type='function'/>
     <exports symbol='virDomainGetName' type='function'/>
     <exports symbol='virNetworkGetAutostart' type='function'/>
     <exports symbol='virDomainDefineXML' type='function'/>
     <exports symbol='virDomainShutdown' type='function'/>
     <exports symbol='virNetworkUndefine' type='function'/>
     <exports symbol='virGetVersion' type='function'/>
     <exports symbol='virConnectListDefinedDomains' type='function'/>
     <exports symbol='virConnectGetCapabilities' type='function'/>
     <exports symbol='virNetworkGetConnect' type='function'/>
     <exports symbol='virDomainLookupByName' type='function'/>
     <exports symbol='virNetworkLookupByUUID' type='function'/>
     <exports symbol='virNetworkGetBridgeName' type='function'/>
     <exports symbol='virNetworkGetXMLDesc' type='function'/>
     <exports symbol='virDomainPinVcpu' type='function'/>
     <exports symbol='virDomainRestore' type='function'/>
     <exports symbol='virConnectGetType' type='function'/>
     <exports symbol='virDomainGetSchedulerParameters' type='function'/>
     <exports symbol='virDomainCreate' type='function'/>
     <exports symbol='virConnectListDomains' type='function'/>
     <exports symbol='virNetworkLookupByUUIDString' type='function'/>
     <exports symbol='virDomainCoreDump' type='function'/>
     <exports symbol='virDomainLookupByUUID' type='function'/>
     <exports symbol='virDomainLookupByUUIDString' type='function'/>
     <exports symbol='virConnectNumOfDefinedNetworks' type='function'/>
     <exports symbol='virDomainUndefine' type='function'/>
     <exports symbol='virDomainGetOSType' type='function'/>
     <exports symbol='virConnectListDefinedNetworks' type='function'/>
     <exports symbol='virNodeGetInfo' type='function'/>
     <exports symbol='virDomainGetUUID' type='function'/>
     <exports symbol='virDomainSetMemory' type='function'/>
     <exports symbol='virNetworkSetAutostart' type='function'/>
     <exports symbol='virConnectNumOfDomains' type='function'/>
     <exports symbol='virDomainGetUUIDString' type='function'/>
     <exports symbol='virDomainGetConnect' type='function'/>
     <exports symbol='virDomainGetMaxMemory' type='function'/>
     <exports symbol='virDomainAttachDevice' type='function'/>
     <exports symbol='virDomainGetMaxVcpus' type='function'/>
     <exports symbol='virDomainFree' type='function'/>
     <exports symbol='virConnectOpen' type='function'/>
     <exports symbol='virDomainSetAutostart' type='function'/>
     <exports symbol='virDomainSuspend' type='function'/>
     <exports symbol='virConnectGetMaxVcpus' type='function'/>
     <exports symbol='virConnectNumOfDefinedDomains' type='function'/>
     <exports symbol='virNetworkDefineXML' type='function'/>
     <exports symbol='virNetworkCreate' type='function'/>
     <exports symbol='virDomainSetSchedulerParameters' type='function'/>
     <exports symbol='virConnectClose' type='function'/>
     <exports symbol='virDomainReboot' type='function'/>
     <exports symbol='virInitialize' type='function'/>
     <exports symbol='virDomainSetVcpus' type='function'/>
     <exports symbol='virDomainLookupByID' type='function'/>
     <exports symbol='virNetworkGetUUIDString' type='function'/>
     <exports symbol='virNetworkLookupByName' type='function'/>
     <exports symbol='virNetworkCreateXML' type='function'/>
     <exports symbol='virDomainGetID' type='function'/>
     <exports symbol='virDomainResume' type='function'/>
     <exports symbol='virDomainCreateLinux' type='function'/>
     <exports symbol='virDomainGetSchedulerType' type='function'/>
     <exports symbol='virNetworkDestroy' type='function'/>
     <exports symbol='virDomainDestroy' type='function'/>
     <exports symbol='virConnectNumOfNetworks' type='function'/>
     <exports symbol='virDomainDetachDevice' type='function'/>
     <exports symbol='virDomainGetAutostart' type='function'/>
     <exports symbol='virDomainGetVcpus' type='function'/>
     <exports symbol='virNetworkGetUUID' type='function'/>
     <exports symbol='virConnectGetHostname' type='function'/>
     <exports symbol='virDomainGetXMLDesc' type='function'/>
     <exports symbol='virDomainSetMaxMemory' type='function'/>
     <exports symbol='virConnectGetVersion' type='function'/>
     <exports symbol='virConnectListNetworks' type='function'/>
     <exports symbol='virConnectGetURI' type='function'/>
     <exports symbol='virDomainSave' type='function'/>
     <exports symbol='virConnectOpenReadOnly' type='function'/>
    </file>
    <file name='virterror'>
     <summary>error handling interfaces for the libvirt library</summary>
     <description>Provides the interfaces of the libvirt library to handle errors raised while using the library. </description>
     <author>Daniel Veillard &lt;veillard@redhat.com&gt; </author>
     <exports symbol='VIR_FROM_XML' type='enum'/>
     <exports symbol='VIR_ERR_RPC' type='enum'/>
     <exports symbol='VIR_ERR_SYSTEM_ERROR' type='enum'/>
     <exports symbol='VIR_FROM_TEST' type='enum'/>
     <exports symbol='VIR_ERR_WARNING' type='enum'/>
     <exports symbol='VIR_ERR_NO_XEN' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_ARG' type='enum'/>
     <exports symbol='VIR_ERR_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_NO_OS' type='enum'/>
     <exports symbol='VIR_ERR_NO_DEVICE' type='enum'/>
     <exports symbol='VIR_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='VIR_FROM_SEXPR' type='enum'/>
     <exports symbol='VIR_FROM_RPC' type='enum'/>
     <exports symbol='VIR_ERR_XML_ERROR' type='enum'/>
     <exports symbol='VIR_FROM_NONE' type='enum'/>
     <exports symbol='VIR_ERR_DOM_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_NO_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_DOM' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_DOMAIN' type='enum'/>
     <exports symbol='VIR_FROM_QEMU' type='enum'/>
     <exports symbol='VIR_FROM_CONF' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_DENIED' type='enum'/>
     <exports symbol='VIR_ERR_NO_KERNEL' type='enum'/>
     <exports symbol='VIR_ERR_GNUTLS_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_POST_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_OS_TYPE' type='enum'/>
     <exports symbol='VIR_WAR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_INVALID_CONN' type='enum'/>
     <exports symbol='VIR_ERR_NONE' type='enum'/>
     <exports symbol='VIR_ERR_OK' type='enum'/>
     <exports symbol='VIR_ERR_XML_DETAIL' type='enum'/>
     <exports symbol='VIR_FROM_NET' type='enum'/>
     <exports symbol='VIR_ERR_NO_NAME' type='enum'/>
     <exports symbol='VIR_ERR_NO_ROOT' type='enum'/>
     <exports symbol='VIR_ERR_OPERATION_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_GET_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_DRIVER_FULL' type='enum'/>
     <exports symbol='VIR_ERR_HTTP_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_PARSE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_NO_SOURCE' type='enum'/>
     <exports symbol='VIR_ERR_NO_TARGET' type='enum'/>
     <exports symbol='VIR_ERR_NETWORK_EXIST' type='enum'/>
     <exports symbol='VIR_ERR_WRITE_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='VIR_ERR_CONF_SYNTAX' type='enum'/>
     <exports symbol='VIR_FROM_REMOTE' type='enum'/>
     <exports symbol='VIR_ERR_NO_SUPPORT' type='enum'/>
     <exports symbol='VIR_FROM_XEND' type='enum'/>
     <exports symbol='VIR_FROM_PROXY' type='enum'/>
     <exports symbol='VIR_ERR_NO_NETWORK' type='enum'/>
     <exports symbol='VIR_ERR_NO_DOMAIN' type='enum'/>
     <exports symbol='VIR_ERR_READ_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_SEXPR_SERIAL' type='enum'/>
     <exports symbol='VIR_FROM_XENSTORE' type='enum'/>
     <exports symbol='VIR_FROM_XEN' type='enum'/>
     <exports symbol='VIR_ERR_OPEN_FAILED' type='enum'/>
     <exports symbol='VIR_ERR_XEN_CALL' type='enum'/>
     <exports symbol='VIR_ERR_UNKNOWN_HOST' type='enum'/>
     <exports symbol='VIR_ERR_NO_CONNECT' type='enum'/>
     <exports symbol='VIR_ERR_CALL_FAILED' type='enum'/>
     <exports symbol='virErrorPtr' type='typedef'/>
     <exports symbol='virErrorLevel' type='typedef'/>
     <exports symbol='virErrorDomain' type='typedef'/>
     <exports symbol='virErrorNumber' type='typedef'/>
     <exports symbol='virError' type='typedef'/>
     <exports symbol='_virError' type='struct'/>
     <exports symbol='virCopyLastError' type='function'/>
     <exports symbol='virConnSetErrorFunc' type='function'/>
     <exports symbol='virResetLastError' type='function'/>
     <exports symbol='virErrorFunc' type='function'/>
     <exports symbol='virResetError' type='function'/>
     <exports symbol='virConnGetLastError' type='function'/>
     <exports symbol='virDefaultErrorFunc' type='function'/>
     <exports symbol='virGetLastError' type='function'/>
     <exports symbol='virSetErrorFunc' type='function'/>
     <exports symbol='virConnCopyLastError' type='function'/>
     <exports symbol='virConnResetLastError' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='LIBVIR_VERSION_NUMBER' file='libvirt'>
      <info>Macro providing the version of the library as version * 1,000,000 + minor * 1000 + micro</info>
    </macro>
    <macro name='VIR_COPY_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_COPY_CPUMAP macro extract the cpumap of the specified vcpu from cpumaps array and copy it into cpumap to be used later by virDomainPinVcpu() API.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpumap' info='pointer to a cpumap (in 8-bit bytes) (OUT) This cpumap must be previously allocated by the caller (ie: malloc(maplen))'/>
    </macro>
    <macro name='VIR_CPU_MAPLEN' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. It returns the length (in bytes) required to store the complete CPU map between a single virtual &amp; all physical CPUs of a domain.</info>
      <arg name='cpu' info='number of physical CPUs'/>
    </macro>
    <macro name='VIR_CPU_USABLE' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() API. VIR_CPU_USABLE macro returns a non zero value (true) if the cpu is usable by the vcpu, and 0 otherwise.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_DOMAIN_SCHED_FIELD_LENGTH' file='libvirt'>
      <info>Macro providing the field length of virSchedParameter</info>
    </macro>
    <macro name='VIR_GET_CPUMAP' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainGetVcpus() and virDomainPinVcpu() APIs. VIR_GET_CPUMAP macro returns a pointer to the cpumap of the specified vcpu from cpumaps array.</info>
      <arg name='cpumaps' info='pointer to an array of cpumap (in 8-bit bytes) (IN)'/>
      <arg name='maplen' info='the length (in bytes) of one cpumap'/>
      <arg name='vcpu' info='the virtual CPU number'/>
    </macro>
    <macro name='VIR_NODEINFO_MAXCPUS' file='libvirt'>
      <info>This macro is to calculate the total number of CPUs supported but not neccessarily active in the host.</info>
      <arg name='nodeinfo' info='virNodeInfo instance'/>
    </macro>
    <macro name='VIR_UNUSE_CPU' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. USE_CPU macro reset the bit (CPU not usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_USE_CPU' file='libvirt'>
      <info>This macro is to be used in conjonction with virDomainPinVcpu() API. USE_CPU macro set the bit (CPU usable) of the related cpu in cpumap.</info>
      <arg name='cpumap' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN/OUT)'/>
      <arg name='cpu' info='the physical CPU number'/>
    </macro>
    <macro name='VIR_UUID_BUFLEN' file='libvirt'>
      <info>This macro provides the length of the buffer required for virDomainGetUUID()</info>
    </macro>
    <macro name='VIR_UUID_STRING_BUFLEN' file='libvirt'>
      <info>This macro provides the length of the buffer required for virDomainGetUUIDString()</info>
    </macro>
    <enum name='VIR_DEVICE_DEFAULT' file='libvirt' value='0' type='virDeviceMode' info='Default mode'/>
    <enum name='VIR_DEVICE_RO' file='libvirt' value='1' type='virDeviceMode' info='Access read-only'/>
    <enum name='VIR_DEVICE_RW' file='libvirt' value='2' type='virDeviceMode' info='Access read-write'/>
    <enum name='VIR_DEVICE_RW_FORCE' file='libvirt' value='3' type='virDeviceMode' info=' Forced read-write even if already used'/>
    <enum name='VIR_DOMAIN_BLOCKED' file='libvirt' value='2' type='virDomainState' info='the domain is blocked on resource'/>
    <enum name='VIR_DOMAIN_CRASHED' file='libvirt' value='6' type='virDomainState' info=' the domain is crashed'/>
    <enum name='VIR_DOMAIN_DESTROY' file='libvirt' value='1' type='virDomainRestart' info='destroy the domain'/>
    <enum name='VIR_DOMAIN_NONE' file='libvirt' value='0' type='virDomainCreateFlags'/>
    <enum name='VIR_DOMAIN_NOSTATE' file='libvirt' value='0' type='virDomainState' info='no state'/>
    <enum name='VIR_DOMAIN_PAUSED' file='libvirt' value='3' type='virDomainState' info='the domain is paused by user'/>
    <enum name='VIR_DOMAIN_PRESERVE' file='libvirt' value='3' type='virDomainRestart' info='keep as is, need manual destroy, for debug'/>
    <enum name='VIR_DOMAIN_RENAME_RESTART' file='libvirt' value='4' type='virDomainRestart' info=' restart under an new unique name'/>
    <enum name='VIR_DOMAIN_RESTART' file='libvirt' value='2' type='virDomainRestart' info='restart the domain'/>
    <enum name='VIR_DOMAIN_RUNNING' file='libvirt' value='1' type='virDomainState' info='the domain is running'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_BOOLEAN' file='libvirt' value='6' type='virSchedParameterType' info=' boolean(character) case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_DOUBLE' file='libvirt' value='5' type='virSchedParameterType' info='double case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_INT' file='libvirt' value='1' type='virSchedParameterType' info='integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_LLONG' file='libvirt' value='3' type='virSchedParameterType' info='long long case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_UINT' file='libvirt' value='2' type='virSchedParameterType' info='unsigned integer case'/>
    <enum name='VIR_DOMAIN_SCHED_FIELD_ULLONG' file='libvirt' value='4' type='virSchedParameterType' info='unsigned long long case'/>
    <enum name='VIR_DOMAIN_SHUTDOWN' file='libvirt' value='4' type='virDomainState' info='the domain is being shut down'/>
    <enum name='VIR_DOMAIN_SHUTOFF' file='libvirt' value='5' type='virDomainState' info='the domain is shut off'/>
    <enum name='VIR_ERR_CALL_FAILED' file='virterror' value='26' type='virErrorNumber' info='not supported by the drivers (DEPRECATED)'/>
    <enum name='VIR_ERR_CONF_SYNTAX' file='virterror' value='33' type='virErrorNumber' info='failed to parse the syntax of a conf file'/>
    <enum name='VIR_ERR_DOM_EXIST' file='virterror' value='28' type='virErrorNumber' info='the domain already exist'/>
    <enum name='VIR_ERR_DRIVER_FULL' file='virterror' value='25' type='virErrorNumber' info='too many drivers registered'/>
    <enum name='VIR_ERR_ERROR' file='virterror' value='2' type='virErrorLevel' info=' An error'/>
    <enum name='VIR_ERR_GET_FAILED' file='virterror' value='10' type='virErrorNumber' info='a HTTP GET command to failed'/>
    <enum name='VIR_ERR_GNUTLS_ERROR' file='virterror' value='40' type='virErrorNumber' info='error from a GNUTLS call'/>
    <enum name='VIR_ERR_HTTP_ERROR' file='virterror' value='12' type='virErrorNumber' info='unexpected HTTP error code'/>
    <enum name='VIR_ERR_INTERNAL_ERROR' file='virterror' value='1' type='virErrorNumber' info='internal error'/>
    <enum name='VIR_ERR_INVALID_ARG' file='virterror' value='8' type='virErrorNumber' info='invalid function argument'/>
    <enum name='VIR_ERR_INVALID_CONN' file='virterror' value='6' type='virErrorNumber' info='invalid connection object'/>
    <enum name='VIR_ERR_INVALID_DOMAIN' file='virterror' value='7' type='virErrorNumber' info='invalid domain object'/>
    <enum name='VIR_ERR_INVALID_NETWORK' file='virterror' value='36' type='virErrorNumber' info='invalid network object'/>
    <enum name='VIR_ERR_NETWORK_EXIST' file='virterror' value='37' type='virErrorNumber' info='the network already exist'/>
    <enum name='VIR_ERR_NONE' file='virterror' value='0' type='virErrorLevel'/>
    <enum name='VIR_ERR_NO_CONNECT' file='virterror' value='5' type='virErrorNumber' info='can&apos;t connect to hypervisor'/>
    <enum name='VIR_ERR_NO_DEVICE' file='virterror' value='23' type='virErrorNumber' info='missing domain devices information'/>
    <enum name='VIR_ERR_NO_DOMAIN' file='virterror' value='42' type='virErrorNumber' info='domain not found or unexpectedly disappeared'/>
    <enum name='VIR_ERR_NO_KERNEL' file='virterror' value='17' type='virErrorNumber' info='missing kernel information'/>
    <enum name='VIR_ERR_NO_MEMORY' file='virterror' value='2' type='virErrorNumber' info='memory allocation failure'/>
    <enum name='VIR_ERR_NO_NAME' file='virterror' value='21' type='virErrorNumber' info='missing domain name information'/>
    <enum name='VIR_ERR_NO_NETWORK' file='virterror' value='43' type='virErrorNumber' info=' network not found'/>
    <enum name='VIR_ERR_NO_OS' file='virterror' value='22' type='virErrorNumber' info='missing domain OS information'/>
    <enum name='VIR_ERR_NO_ROOT' file='virterror' value='18' type='virErrorNumber' info='missing root device information'/>
    <enum name='VIR_ERR_NO_SOURCE' file='virterror' value='19' type='virErrorNumber' info='missing source device information'/>
    <enum name='VIR_ERR_NO_SUPPORT' file='virterror' value='3' type='virErrorNumber' info='no support for this function'/>
    <enum name='VIR_ERR_NO_TARGET' file='virterror' value='20' type='virErrorNumber' info='missing target device information'/>
    <enum name='VIR_ERR_NO_XEN' file='virterror' value='14' type='virErrorNumber' info='could not open Xen hypervisor control'/>
    <enum name='VIR_ERR_NO_XENSTORE' file='virterror' value='24' type='virErrorNumber' info='could not open Xen Store control'/>
    <enum name='VIR_ERR_OK' file='virterror' value='0' type='virErrorNumber'/>
    <enum name='VIR_ERR_OPEN_FAILED' file='virterror' value='30' type='virErrorNumber' info='failed to open a conf file'/>
    <enum name='VIR_ERR_OPERATION_DENIED' file='virterror' value='29' type='virErrorNumber' info='operation forbidden on read-only connections'/>
    <enum name='VIR_ERR_OPERATION_FAILED' file='virterror' value='9' type='virErrorNumber' info='a command to hypervisor failed'/>
    <enum name='VIR_ERR_OS_TYPE' file='virterror' value='16' type='virErrorNumber' info='unknown OS type'/>
    <enum name='VIR_ERR_PARSE_FAILED' file='virterror' value='32' type='virErrorNumber' info='failed to parse a conf file'/>
    <enum name='VIR_ERR_POST_FAILED' file='virterror' value='11' type='virErrorNumber' info='a HTTP POST command to failed'/>
    <enum name='VIR_ERR_READ_FAILED' file='virterror' value='31' type='virErrorNumber' info='failed to read a conf file'/>
    <enum name='VIR_ERR_RPC' file='virterror' value='39' type='virErrorNumber' info='some sort of RPC error'/>
    <enum name='VIR_ERR_SEXPR_SERIAL' file='virterror' value='13' type='virErrorNumber' info='failure to serialize an S-Expr'/>
    <enum name='VIR_ERR_SYSTEM_ERROR' file='virterror' value='38' type='virErrorNumber' info='general system call failure'/>
    <enum name='VIR_ERR_UNKNOWN_HOST' file='virterror' value='4' type='virErrorNumber' info='could not resolve hostname'/>
    <enum name='VIR_ERR_WARNING' file='virterror' value='1' type='virErrorLevel' info='A simple warning'/>
    <enum name='VIR_ERR_WRITE_FAILED' file='virterror' value='34' type='virErrorNumber' info='failed to write a conf file'/>
    <enum name='VIR_ERR_XEN_CALL' file='virterror' value='15' type='virErrorNumber' info='failure doing an hypervisor call'/>
    <enum name='VIR_ERR_XML_DETAIL' file='virterror' value='35' type='virErrorNumber' info='detail of an XML error'/>
    <enum name='VIR_ERR_XML_ERROR' file='virterror' value='27' type='virErrorNumber' info='an XML description is not well formed or broken'/>
    <enum name='VIR_FROM_CONF' file='virterror' value='9' type='virErrorDomain' info='Error in the configuration file handling'/>
    <enum name='VIR_FROM_DOM' file='virterror' value='6' type='virErrorDomain' info='Error when operating on a domain'/>
    <enum name='VIR_FROM_NET' file='virterror' value='11' type='virErrorDomain' info='Error when operating on a network'/>
    <enum name='VIR_FROM_NONE' file='virterror' value='0' type='virErrorDomain'/>
    <enum name='VIR_FROM_PROXY' file='virterror' value='8' type='virErrorDomain' info='Error in the proxy code'/>
    <enum name='VIR_FROM_QEMU' file='virterror' value='10' type='virErrorDomain' info='Error at the QEMU daemon'/>
    <enum name='VIR_FROM_REMOTE' file='virterror' value='13' type='virErrorDomain' info=' Error from remote driver'/>
    <enum name='VIR_FROM_RPC' file='virterror' value='7' type='virErrorDomain' info='Error in the XML-RPC code'/>
    <enum name='VIR_FROM_SEXPR' file='virterror' value='4' type='virErrorDomain' info='Error in the S-Epression code'/>
    <enum name='VIR_FROM_TEST' file='virterror' value='12' type='virErrorDomain' info='Error from test driver'/>
    <enum name='VIR_FROM_XEN' file='virterror' value='1' type='virErrorDomain' info='Error at Xen hypervisor layer'/>
    <enum name='VIR_FROM_XEND' file='virterror' value='2' type='virErrorDomain' info='Error at connection with xend daemon'/>
    <enum name='VIR_FROM_XENSTORE' file='virterror' value='3' type='virErrorDomain' info='Error at connection with xen store'/>
    <enum name='VIR_FROM_XML' file='virterror' value='5' type='virErrorDomain' info='Error in the XML code'/>
    <enum name='VIR_VCPU_BLOCKED' file='libvirt' value='2' type='virVcpuState' info=' the virtual CPU is blocked on resource'/>
    <enum name='VIR_VCPU_OFFLINE' file='libvirt' value='0' type='virVcpuState' info='the virtual CPU is offline'/>
    <enum name='VIR_VCPU_RUNNING' file='libvirt' value='1' type='virVcpuState' info='the virtual CPU is running'/>
    <enum name='VIR_WAR_NO_NETWORK' file='virterror' value='41' type='virErrorNumber' info='failed to start network'/>
    <struct name='virConnect' file='libvirt' type='struct _virConnect'/>
    <typedef name='virConnectPtr' file='libvirt' type='virConnect *'>
      <info>a virConnectPtr is pointer to a virConnect private structure, this is the type used to reference a connection to the Xen Hypervisor in the API.</info>
    </typedef>
    <typedef name='virDeviceMode' file='libvirt' type='enum'/>
    <struct name='virDomain' file='libvirt' type='struct _virDomain'/>
    <typedef name='virDomainCreateFlags' file='libvirt' type='enum'/>
    <struct name='virDomainInfo' file='libvirt' type='struct _virDomainInfo'>
      <field name='state' type='unsigned char' info=' the running state, one of virDomainFlags'/>
      <field name='maxMem' type='unsigned long' info=' the maximum memory in KBytes allowed'/>
      <field name='memory' type='unsigned long' info=' the memory in KBytes used by the domain'/>
      <field name='nrVirtCpu' type='unsigned short' info=' the number of virtual CPUs for the domain'/>
      <field name='cpuTime' type='unsigned long long' info=' the CPU time used in nanoseconds'/>
    </struct>
    <typedef name='virDomainInfoPtr' file='libvirt' type='virDomainInfo *'>
      <info>a virDomainInfoPtr is a pointer to a virDomainInfo structure.</info>
    </typedef>
    <typedef name='virDomainPtr' file='libvirt' type='virDomain *'>
      <info>a virDomainPtr is pointer to a virDomain private structure, this is the type used to reference a Xen domain in the API.</info>
    </typedef>
    <typedef name='virDomainRestart' file='libvirt' type='enum'/>
    <typedef name='virDomainState' file='libvirt' type='enum'/>
    <struct name='virError' file='virterror' type='struct _virError'>
      <field name='code' type='int' info=' The error code, a virErrorNumber'/>
      <field name='domain' type='int' info=' What part of the library raised this error'/>
      <field name='message' type='char *' info=' human-readable informative error message'/>
      <field name='level' type='virErrorLevel' info=' how consequent is the error'/>
      <field name='conn' type='virConnectPtr' info=' the connection if available'/>
      <field name='dom' type='virDomainPtr' info=' the domain if available'/>
      <field name='str1' type='char *' info=' extra string information'/>
      <field name='str2' type='char *' info=' extra string information'/>
      <field name='str3' type='char *' info=' extra string information'/>
      <field name='int1' type='int' info=' extra number information'/>
      <field name='int2' type='int' info=' extra number information'/>
      <field name='net' type='virNetworkPtr' info=' the network if available'/>
    </struct>
    <typedef name='virErrorDomain' file='virterror' type='enum'/>
    <typedef name='virErrorLevel' file='virterror' type='enum'/>
    <typedef name='virErrorNumber' file='virterror' type='enum'/>
    <typedef name='virErrorPtr' file='virterror' type='virError *'/>
    <struct name='virNetwork' file='libvirt' type='struct _virNetwork'/>
    <typedef name='virNetworkPtr' file='libvirt' type='virNetwork *'>
      <info>a virNetworkPtr is pointer to a virNetwork private structure, this is the type used to reference a virtual network in the API.</info>
    </typedef>
    <struct name='virNodeInfo' file='libvirt' type='struct _virNodeInfo'>
      <field name='model' type='charmodel[32]' info=' string indicating the CPU model'/>
      <field name='memory' type='unsigned long' info=' memory size in kilobytes'/>
      <field name='cpus' type='unsigned int' info=' the number of active CPUs'/>
      <field name='mhz' type='unsigned int' info=' expected CPU frequency'/>
      <field name='nodes' type='unsigned int' info=' the number of NUMA cell, 1 for uniform mem access'/>
      <field name='sockets' type='unsigned int' info=' number of CPU socket per node'/>
      <field name='cores' type='unsigned int' info=' number of core per socket'/>
      <field name='threads' type='unsigned int' info=' number of threads per core'/>
    </struct>
    <typedef name='virNodeInfoPtr' file='libvirt' type='virNodeInfo *'>
      <info>a virNodeInfoPtr is a pointer to a virNodeInfo structure.</info>
    </typedef>
    <struct name='virSchedParameter' file='libvirt' type='struct _virSchedParameter'>
      <field name='field' type='charfield[VIR_DOMAIN_SCHED_FIELD_LENGTH]' info=' parameter name'/>
      <field name='type' type='int' info=' parameter type'/>
    </struct>
    <typedef name='virSchedParameterPtr' file='libvirt' type='virSchedParameter *'>
      <info>a virSchedParameterPtr is a pointer to a virSchedParameter structure.</info>
    </typedef>
    <typedef name='virSchedParameterType' file='libvirt' type='enum'/>
    <struct name='virVcpuInfo' file='libvirt' type='struct _virVcpuInfo'>
      <field name='number' type='unsigned int' info=' virtual CPU number'/>
      <field name='state' type='int' info=' value from virVcpuState'/>
      <field name='cpuTime' type='unsigned long long' info=' CPU time used, in nanoseconds'/>
      <field name='cpu' type='int' info=' real CPU number, or -1 if offline'/>
    </struct>
    <typedef name='virVcpuInfoPtr' file='libvirt' type='virVcpuInfo *'/>
    <typedef name='virVcpuState' file='libvirt' type='enum'/>
    <function name='virConnCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught on that connection One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virConnGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught on that connection Simpler but may not be suitable for multithreaded accesses, in which case use virConnCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occured.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught on that connection</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a connection error handling function, if @handler is NULL it will reset to default which is to pass error back to the global library handler.</info>
      <return type='void'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
    <function name='virConnectClose' file='libvirt' module='libvirt'>
      <info>This function closes the connection to the Hypervisor. This should not be called if further interaction with the Hypervisor are needed especially if there is running domain which need further monitoring by the application.</info>
      <return type='int' info='0 in case of success or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetCapabilities' file='libvirt' module='libvirt'>
      <info>Provides capabilities of the hypervisor / driver.</info>
      <return type='char *' info='NULL in case of error, or a pointer to an opaque virCapabilities structure (virCapabilitiesPtr). The client must free the returned string after use.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetHostname' file='libvirt' module='libvirt'>
      <info>This returns the system hostname on which the hypervisor is running (the result of the gethostname(2) system call).  If we are connected to a remote system, then this returns the hostname of the remote system.</info>
      <return type='char *' info='the hostname which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetMaxVcpus' file='libvirt' module='libvirt'>
      <info>Provides the maximum number of virtual CPUs supported for a guest VM of a specific type. The &apos;type&apos; parameter here corresponds to the &apos;type&apos; attribute in the &lt;domain&gt; element of the XML.</info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='type' type='const char *' info='value of the &apos;type&apos; attribute in the &lt;domain&gt; element'/>
    </function>
    <function name='virConnectGetType' file='libvirt' module='libvirt'>
      <info>Get the name of the Hypervisor software used.</info>
      <return type='const char *' info='NULL in case of error, a static zero terminated string otherwise.  See also: http://www.redhat.com/archives/libvir-list/2007-February/msg00096.html'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectGetURI' file='libvirt' module='libvirt'>
      <info>This returns the URI (name) of the hypervisor connection. Normally this is the same as or similar to the string passed to the virConnectOpen/virConnectOpenReadOnly call, but the driver may make the URI canonical.  If name == NULL was passed to virConnectOpen, then the driver will return a non-NULL URI which can be used to connect to the same hypervisor later.</info>
      <return type='char *' info='the URI string which must be freed by the caller, or NULL if there was an error.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to a hypervisor connection'/>
    </function>
    <function name='virConnectGetVersion' file='libvirt' module='libvirt'>
      <info>Get the version level of the Hypervisor running. This may work only with hypervisor call, i.e. with priviledged access to the hypervisor, not with a Read-Only connection.</info>
      <return type='int' info='-1 in case of error, 0 otherwise. if the version can&apos;t be extracted by lack of capacities returns 0 and @hvVer is 0, otherwise @hvVer value is major * 1,000,000 + minor * 1,000 + release'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='hvVer' type='unsigned long *' info='return value for the version of the running hypervisor (OUT)'/>
    </function>
    <function name='virConnectListDefinedDomains' file='libvirt' module='libvirt'>
      <info>list the defined domains, stores the pointers to the names in @names</info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDefinedNetworks' file='libvirt' module='libvirt'>
      <info>list the inactive networks, stores the pointers to the names in @names</info>
      <return type='int' info='the number of names provided in the array or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='pointer to an array to store the names'/>
      <arg name='maxnames' type='int' info='size of the array'/>
    </function>
    <function name='virConnectListDomains' file='libvirt' module='libvirt'>
      <info>Collect the list of active domains, and store their ID in @maxids</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='ids' type='int *' info='array to collect the list of IDs of active domains'/>
      <arg name='maxids' type='int' info='size of @ids'/>
    </function>
    <function name='virConnectListNetworks' file='libvirt' module='libvirt'>
      <info>Collect the list of active networks, and store their names in @names</info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='names' type='char ** const' info='array to collect the list of names of active networks'/>
      <arg name='maxnames' type='int' info='size of @names'/>
    </function>
    <function name='virConnectNumOfDefinedDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of inactive domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDefinedNetworks' file='libvirt' module='libvirt'>
      <info>Provides the number of inactive networks.</info>
      <return type='int' info='the number of networks found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfDomains' file='libvirt' module='libvirt'>
      <info>Provides the number of active domains.</info>
      <return type='int' info='the number of domain found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectNumOfNetworks' file='libvirt' module='libvirt'>
      <info>Provides the number of active networks.</info>
      <return type='int' info='the number of network found or -1 in case of error'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
    </function>
    <function name='virConnectOpen' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a connection to the Hypervisor and xen store</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virConnectOpenReadOnly' file='libvirt' module='libvirt'>
      <info>This function should be called first to get a restricted connection to the libbrary functionalities. The set of APIs usable are then restricted on the available methods to control the domains.</info>
      <return type='virConnectPtr' info='a pointer to the hypervisor connection or NULL in case of error  URIs are documented at http://libvirt.org/uri.html'/>
      <arg name='name' type='const char *' info='URI of the hypervisor'/>
    </function>
    <function name='virCopyLastError' file='virterror' module='virterror'>
      <info>Copy the content of the last error caught at the library level One will need to free the result with virResetError()</info>
      <return type='int' info='0 if no error was found and the error code otherwise and -1 in case of parameter error.'/>
      <arg name='to' type='virErrorPtr' info='target to receive the copy'/>
    </function>
    <function name='virDefaultErrorFunc' file='virterror' module='virterror'>
      <info>Default routine reporting an error to stderr.</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='virDomainAttachDevice' file='libvirt' module='libvirt'>
      <info>Create a virtual device attachment to backend.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainCoreDump' file='libvirt' module='libvirt'>
      <info>This method will dump the core of a domain on a given file for analysis. Note that for remote Xen Daemon the file path will be interpreted in the remote host.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the core file'/>
      <arg name='flags' type='int' info='extra flags, currently unused'/>
    </function>
    <function name='virDomainCreate' file='libvirt' module='libvirt'>
      <info>launch a defined domain. If the call succeed the domain moves from the defined to the running domains pools.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <function name='virDomainCreateLinux' file='libvirt' module='libvirt'>
      <info>Launch a new Linux guest domain, based on an XML description similar to the one returned by virDomainGetXMLDesc() This function may requires priviledged access to the hypervisor.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the domain'/>
      <arg name='flags' type='unsigned int' info='an optional set of virDomainFlags'/>
    </function>
    <function name='virDomainDefineXML' file='libvirt' module='libvirt'>
      <info>define a domain, but does not start it</info>
      <return type='virDomainPtr' info='NULL in case of error, a pointer to the domain otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the domain, preferably in UTF-8'/>
    </function>
    <function name='virDomainDestroy' file='libvirt' module='libvirt'>
      <info>Destroy the domain object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. The data structure is freed and should not be used thereafter if the call does not return an error. This function may requires priviledged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainDetachDevice' file='libvirt' module='libvirt'>
      <info>Destroy a virtual device attachment to backend.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='xml' type='char *' info='pointer to XML description of one device'/>
    </function>
    <function name='virDomainFree' file='libvirt' module='libvirt'>
      <info>Free the domain object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetAutostart' file='libvirt' module='libvirt'>
      <info>Provides a boolean value indicating whether the domain configured to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virDomainGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a domain.  The reference counter on the connection is not increased by this call.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='dom' type='virDomainPtr' info='pointer to a domain'/>
    </function>
    <function name='virDomainGetID' file='libvirt' module='libvirt'>
      <info>Get the hypervisor ID number for the domain</info>
      <return type='unsigned int' info='the domain ID number or (unsigned int) -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetInfo' file='libvirt' module='libvirt'>
      <info>Extract information about a domain. Note that if the connection used to get the domain is limited only a partial set of the information can be extracted.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='info' type='virDomainInfoPtr' info='pointer to a virDomainInfo structure allocated by the user'/>
    </function>
    <function name='virDomainGetMaxMemory' file='libvirt' module='libvirt'>
      <info>Retrieve the maximum amount of physical memory allocated to a domain. If domain is NULL, then this get the amount of memory reserved to Domain0 i.e. the domain where the application runs.</info>
      <return type='unsigned long' info='the memory size in kilobytes or 0 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
    </function>
    <function name='virDomainGetMaxVcpus' file='libvirt' module='libvirt'>
      <info>Provides the maximum number of virtual CPUs supported for the guest VM. If the guest is inactive, this is basically the same as virConnectGetMaxVcpus. If the guest is running this will reflect the maximum number of virtual CPUs the guest was booted with.</info>
      <return type='int' info='the maximum of virtual CPU or -1 in case of error.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
    </function>
    <function name='virDomainGetName' file='libvirt' module='libvirt'>
      <info>Get the public name for that domain</info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the domain object.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetOSType' file='libvirt' module='libvirt'>
      <info>Get the type of domain operation system.</info>
      <return type='char *' info='the new string or NULL in case of error, the string must be freed by the caller.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainGetSchedulerParameters' file='libvirt' module='libvirt'>
      <info>Get the scheduler parameters, the @params array will be filled with the values.</info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter object (return value)'/>
      <arg name='nparams' type='int *' info='pointer to number of scheduler parameter (this value should be same than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainGetSchedulerType' file='libvirt' module='libvirt'>
      <info>Get the scheduler type.</info>
      <return type='char *' info='NULL in case of error. The caller must free the returned string.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='nparams' type='int *' info='number of scheduler parameters(return value)'/>
    </function>
    <function name='virDomainGetUUID' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetUUIDString' file='libvirt' module='libvirt'>
      <info>Get the UUID for a domain as string. For more information about UUID see RFC4122.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virDomainGetVcpus' file='libvirt' module='libvirt'>
      <info>Extract information about virtual CPUs of domain, store it in info array and also in cpumaps if this pointer is&apos;nt NULL.</info>
      <return type='int' info='the number of info filled in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='info' type='virVcpuInfoPtr' info='pointer to an array of virVcpuInfo structures (OUT)'/>
      <arg name='maxinfo' type='int' info='number of structures in info array'/>
      <arg name='cpumaps' type='unsigned char *' info='pointer to an bit map of real CPUs for all vcpus of this domain (in 8-bit bytes) (OUT) If cpumaps is NULL, then no cupmap information is returned by the API. It&apos;s assumed there is &lt;maxinfo&gt; cpumap in cpumaps array. The memory allocated to cpumaps must be (maxinfo * maplen) bytes (ie: calloc(maxinfo, maplen)). One cpumap inside cpumaps has the format described in virDomainPinVcpu() API.'/>
      <arg name='maplen' type='int' info='number of bytes in one cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...).'/>
    </function>
    <function name='virDomainGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Provide an XML description of the domain. The description may be reused later to relaunch the domain with virDomainCreateLinux().</info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virDomainLookupByID' file='libvirt' module='libvirt'>
      <info>Try to find a domain based on the hypervisor ID number</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='id' type='int' info='the domain ID number'/>
    </function>
    <function name='virDomainLookupByName' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its name.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the domain'/>
    </function>
    <function name='virDomainLookupByUUID' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the domain'/>
    </function>
    <function name='virDomainLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Try to lookup a domain on the given hypervisor based on its UUID.</info>
      <return type='virDomainPtr' info='a new domain object or NULL in case of failure.  If the domain cannot be found, then VIR_ERR_NO_DOMAIN error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the domain'/>
    </function>
    <function name='virDomainPinVcpu' file='libvirt' module='libvirt'>
      <info>Dynamically change the real CPUs which can be allocated to a virtual CPU. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='vcpu' type='unsigned int' info='virtual CPU number'/>
      <arg name='cpumap' type='unsigned char *' info='pointer to a bit map of real CPUs (in 8-bit bytes) (IN) Each bit set to 1 means that corresponding CPU is usable. Bytes are stored in little-endian order: CPU0-7, 8-15... In each byte, lowest CPU number is least significant bit.'/>
      <arg name='maplen' type='int' info='number of bytes in cpumap, from 1 up to size of CPU map in underlying virtualization system (Xen...). If maplen &lt; size, missing bytes are set to zero. If maplen &gt; size, failure code is returned.'/>
    </function>
    <function name='virDomainReboot' file='libvirt' module='libvirt'>
      <info>Reboot a domain, the domain object is still usable there after but the domain OS is being stopped for a restart. Note that the guest OS may ignore the request.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='flags' type='unsigned int' info='extra flags for the reboot operation, not used yet'/>
    </function>
    <function name='virDomainRestore' file='libvirt' module='libvirt'>
      <info>This method will restore a domain saved to disk by virDomainSave().</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='from' type='const char *' info='path to the'/>
    </function>
    <function name='virDomainResume' file='libvirt' module='libvirt'>
      <info>Resume an suspended domain, the process is restarted from the state where it was frozen by calling virSuspendDomain(). This function may requires priviledged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSave' file='libvirt' module='libvirt'>
      <info>This method will suspend a domain and save its memory contents to a file on disk. After the call, if successful, the domain is not listed as running anymore (this may be a problem). Use virDomainRestore() to restore a domain after saving.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='to' type='const char *' info='path for the output file'/>
    </function>
    <function name='virDomainSetAutostart' file='libvirt' module='libvirt'>
      <info>Configure the domain to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
      <arg name='autostart' type='int' info='whether the domain should be automatically started 0 or 1'/>
    </function>
    <function name='virDomainSetMaxMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the maximum amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetMemory' file='libvirt' module='libvirt'>
      <info>Dynamically change the target amount of physical memory allocated to a domain. If domain is NULL, then this change the amount of memory reserved to Domain0 i.e. the domain where the application runs. This function may requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object or NULL'/>
      <arg name='memory' type='unsigned long' info='the memory size in kilobytes'/>
    </function>
    <function name='virDomainSetSchedulerParameters' file='libvirt' module='libvirt'>
      <info>Change the scheduler parameters</info>
      <return type='int' info='-1 in case of error, 0 in case of success.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object'/>
      <arg name='params' type='virSchedParameterPtr' info='pointer to scheduler parameter objects'/>
      <arg name='nparams' type='int' info='number of scheduler parameter (this value should be same or less than the returned value nparams of virDomainGetSchedulerType)'/>
    </function>
    <function name='virDomainSetVcpus' file='libvirt' module='libvirt'>
      <info>Dynamically change the number of virtual CPUs used by the domain. Note that this call may fail if the underlying virtualization hypervisor does not support it or if growing the number is arbitrary limited. This function requires priviledged access to the hypervisor.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='pointer to domain object, or NULL for Domain0'/>
      <arg name='nvcpus' type='unsigned int' info='the new number of virtual CPUs for this domain'/>
    </function>
    <function name='virDomainShutdown' file='libvirt' module='libvirt'>
      <info>Shutdown a domain, the domain object is still usable there after but the domain OS is being stopped. Note that the guest OS may ignore the request.  TODO: should we add an option for reboot, knowing it may not be doable in the general case ?</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainSuspend' file='libvirt' module='libvirt'>
      <info>Suspends an active domain, the process is frozen without further access to CPU resources and I/O but the memory used by the domain at the hypervisor level will stay allocated. Use virDomainResume() to reactivate the domain. This function may requires priviledged access.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='domain' type='virDomainPtr' info='a domain object'/>
    </function>
    <function name='virDomainUndefine' file='libvirt' module='libvirt'>
      <info>undefine a domain but does not stop it if it is running</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='domain' type='virDomainPtr' info='pointer to a defined domain'/>
    </function>
    <functype name='virErrorFunc' file='virterror' module='virterror'>
      <info>Signature of a function to use when there is an error raised by the library.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='virErrorPtr' info='the error being raised.'/>
    </functype>
    <function name='virGetLastError' file='virterror' module='virterror'>
      <info>Provide a pointer to the last error caught at the library level Simpler but may not be suitable for multithreaded accesses, in which case use virCopyLastError()</info>
      <return type='virErrorPtr' info='a pointer to the last error or NULL if none occured.'/>
    </function>
    <function name='virGetVersion' file='libvirt' module='libvirt'>
      <info>Provides two information back, @libVer is the version of the library while @typeVer will be the version of the hypervisor type @type against which the library was compiled. If @type is NULL, &quot;Xen&quot; is assumed, if @type is unknown or not availble, an error code will be returned and @typeVer will be 0.</info>
      <return type='int' info='-1 in case of failure, 0 otherwise, and values for @libVer and @typeVer have the format major * 1,000,000 + minor * 1,000 + release.'/>
      <arg name='libVer' type='unsigned long *' info='return value for the library version (OUT)'/>
      <arg name='type' type='const char *' info='the type of connection/driver looked at'/>
      <arg name='typeVer' type='unsigned long *' info='return value for the version of the hypervisor (OUT)'/>
    </function>
    <function name='virInitialize' file='libvirt' module='libvirt'>
      <info>Initialize the library. It&apos;s better to call this routine at startup in multithreaded applications to avoid potential race when initializing the library.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
    </function>
    <function name='virNetworkCreate' file='libvirt' module='libvirt'>
      <info>Create and start a defined network. If the call succeed the network moves from the defined to the running networks pools.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNetworkCreateXML' file='libvirt' module='libvirt'>
      <info>Create and start a new virtual network, based on an XML description similar to the one returned by virNetworkGetXMLDesc()</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xmlDesc' type='const char *' info='an XML description of the network'/>
    </function>
    <function name='virNetworkDefineXML' file='libvirt' module='libvirt'>
      <info>Define a network, but does not create it</info>
      <return type='virNetworkPtr' info='NULL in case of error, a pointer to the network otherwise'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='xml' type='const char *' info='the XML description for the network, preferably in UTF-8'/>
    </function>
    <function name='virNetworkDestroy' file='libvirt' module='libvirt'>
      <info>Destroy the network object. The running instance is shutdown if not down already and all resources used by it are given back to the hypervisor. The data structure is freed and should not be used thereafter if the call does not return an error. This function may requires priviledged access</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkFree' file='libvirt' module='libvirt'>
      <info>Free the network object. The running instance is kept alive. The data structure is freed and should not be used thereafter.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetAutostart' file='libvirt' module='libvirt'>
      <info>Provides a boolean value indicating whether the network configured to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int *' info='the value returned'/>
    </function>
    <function name='virNetworkGetBridgeName' file='libvirt' module='libvirt'>
      <info>Provides a bridge interface name to which a domain may connect a network interface in order to join the network.</info>
      <return type='char *' info='a 0 terminated interface name, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetConnect' file='libvirt' module='libvirt'>
      <info>Provides the connection pointer associated with a network.  The reference counter on the connection is not increased by this call.</info>
      <return type='virConnectPtr' info='the virConnectPtr or NULL in case of failure.'/>
      <arg name='net' type='virNetworkPtr' info='pointer to a network'/>
    </function>
    <function name='virNetworkGetName' file='libvirt' module='libvirt'>
      <info>Get the public name for that network</info>
      <return type='const char *' info='a pointer to the name or NULL, the string need not be deallocated its lifetime will be the same as the network object.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
    </function>
    <function name='virNetworkGetUUID' file='libvirt' module='libvirt'>
      <info>Get the UUID for a network</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='uuid' type='unsigned char *' info='pointer to a VIR_UUID_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetUUIDString' file='libvirt' module='libvirt'>
      <info>Get the UUID for a network as string. For more information about UUID see RFC4122.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='buf' type='char *' info='pointer to a VIR_UUID_STRING_BUFLEN bytes array'/>
    </function>
    <function name='virNetworkGetXMLDesc' file='libvirt' module='libvirt'>
      <info>Provide an XML description of the network. The description may be reused later to relaunch the network with virNetworkCreateXML().</info>
      <return type='char *' info='a 0 terminated UTF-8 encoded XML instance, or NULL in case of error. the caller must free() the returned value.'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='flags' type='int' info='and OR&apos;ed set of extraction flags, not used yet'/>
    </function>
    <function name='virNetworkLookupByName' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its name.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='name' type='const char *' info='name for the network'/>
    </function>
    <function name='virNetworkLookupByUUID' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its UUID.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuid' type='const unsigned char *' info='the raw UUID for the network'/>
    </function>
    <function name='virNetworkLookupByUUIDString' file='libvirt' module='libvirt'>
      <info>Try to lookup a network on the given hypervisor based on its UUID.</info>
      <return type='virNetworkPtr' info='a new network object or NULL in case of failure.  If the network cannot be found, then VIR_ERR_NO_NETWORK error is raised.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='uuidstr' type='const char *' info='the string UUID for the network'/>
    </function>
    <function name='virNetworkSetAutostart' file='libvirt' module='libvirt'>
      <info>Configure the network to be automatically started when the host machine boots.</info>
      <return type='int' info='-1 in case of error, 0 in case of success'/>
      <arg name='network' type='virNetworkPtr' info='a network object'/>
      <arg name='autostart' type='int' info='whether the network should be automatically started 0 or 1'/>
    </function>
    <function name='virNetworkUndefine' file='libvirt' module='libvirt'>
      <info>Undefine a network but does not stop it if it is running</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='network' type='virNetworkPtr' info='pointer to a defined network'/>
    </function>
    <function name='virNodeGetInfo' file='libvirt' module='libvirt'>
      <info>Extract hardware information about the node.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='conn' type='virConnectPtr' info='pointer to the hypervisor connection'/>
      <arg name='info' type='virNodeInfoPtr' info='pointer to a virNodeInfo structure allocated by the user'/>
    </function>
    <function name='virResetError' file='virterror' module='virterror'>
      <info>Reset the error being pointed to</info>
      <return type='void'/>
      <arg name='err' type='virErrorPtr' info='pointer to the virError to clean up'/>
    </function>
    <function name='virResetLastError' file='virterror' module='virterror'>
      <info>Reset the last error caught at the library level.</info>
      <return type='void'/>
    </function>
    <function name='virSetErrorFunc' file='virterror' module='virterror'>
      <info>Set a library global error handling function, if @handler is NULL, it will reset to default printing on stderr. The error raised there are those for which no handler at the connection level could caught.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='pointer to the user data provided in the handler callback'/>
      <arg name='handler' type='virErrorFunc' info='the function to get called in case of error or NULL'/>
    </function>
  </symbols>
</api>
